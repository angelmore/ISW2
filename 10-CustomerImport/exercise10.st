Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Address methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !Object subclass: #Customer	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:27'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:25'!addresses	^ addresses! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 09:43'!numberOfAddresses		^addresses size! !!Customer methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/1/2016 10:05'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Customer methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/1/2016 18:03'!addressesIsEmpty		^addresses isEmpty! !!Customer methodsFor: 'testing' stamp: 'angelmore 11/19/2017 19:46'!isAt: aFirstName		^firstName = aFirstName. ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationType		^identificationType ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationNumber		^identificationNumber ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'initialization' stamp: 'HernanWilkinson 10/28/2016 13:26'!initialize	super initialize.	addresses := OrderedCollection new.! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'session importer system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data' stamp: 'angelmore 11/19/2017 15:54'!validTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:39'!testEmptyLinesAreRecognizedAsInvalidRecords		self		should: [ self importCustomersFrom: self dataWithEmptyLine ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:39'!testImportCustomers	self importCustomersFrom: self validTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:39'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self 		should: [ self importCustomersFrom: self addressRecordStartingWithMoreThanOneATestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:39'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self 		should: [ self importCustomersFrom: self customerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: self customersIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:39'!testCanNotImportCustomerRecordWithLessThanFiveFields	self 		should: [ self importCustomersFrom: self customerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: self customersIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:39'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self 		should: [ self importCustomersFrom: self customerRecordStartingWithMoreThanOneCTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError |			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self customersIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:38'!testCanNotImportAddressRecordWithMoreThanSixFields	self 		should: [ self importCustomersFrom: self addressRecordWithMoreThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:38'!testCanNotImportAddressWithoutCustomer	self 		should: [ self importCustomersFrom: self addressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError |			self assert: anError messageText equals: CustomerImporter addressWithoutCustomerErrorDescription.			self assert: self customersIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:38'!testCanNotImportAddressRecordWithLessThanSixFields		self		should: [ self importCustomersFrom: self addressRecordWithLessThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/1/2016 15:59'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'angelmore 11/19/2017 19:39'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 16:02'!assertImportedCustomersSizeIsCorrect	self assert: self allCustomers size equals: 2! !!CustomerImportTest methodsFor: 'asserting' stamp: 'angelmore 11/19/2017 17:02'!assertJuanPerezWasImportedCorrectly		| customer idType idNumber |		idType := 'C'.	idNumber := '23-25666777-9'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Juan' lastName: 'Perez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 1.	self assert: customer hasAddressAt: 'Alem' number: 1122 in: 'CABA' zipCode: 1001 province: 'CABA'.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 15:16'!assertPepeSanchezWasImportedCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'importing' stamp: 'Angel 11/13/2017 22:42'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ system		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!CustomerImportTest methodsFor: 'importing' stamp: 'angelmore 11/19/2017 15:38'!importCustomersFrom: inputStream	system importCustomersFrom: inputStream! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'ANgel 11/16/2017 19:36'!setUp	system := Environment current createCustomerSystem.	system start! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/1/2016 15:24'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'Angel 11/13/2017 21:00'!tearDown	system stop! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/1/2016 15:23'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerIdNumber	^ '22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomer	^ self		customerIdentifiedAs: self alwaysImportedCustomerIdType		numbered: self alwaysImportedCustomerIdNumber! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'customers' stamp: 'Angel 11/13/2017 23:02'!customersIsEmpty		^(self allCustomers) isEmpty! !!CustomerImportTest methodsFor: 'customers' stamp: 'Angel 11/13/2017 21:02'!allCustomers	^ system allCustomers! !Object subclass: #CustomerImporter	instanceVariableNames: 'line readStream session record newCustomer system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImporter methodsFor: 'initialization' stamp: 'Angel 11/13/2017 22:37'!initializeOn: aReadStream on: aSystem	readStream := aReadStream.	system := aSystem.! !!CustomerImporter methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 17:51'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!CustomerImporter methodsFor: 'importing' stamp: 'angelmore 11/19/2017 15:38'!importCustomersFrom: inputStream	system importCustomersFrom: inputStream! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidCustomerRecordSize		record size ~= 5 ifTrue: [ self signalInvalidCustomerRecord ].	! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'Angel 11/13/2017 22:54'!importCustomer	self assertValidCustomerRecordSize.		newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	^ system persistCustomer: newCustomer.! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/2/2016 10:55'!isCustomerRecord	^ record first = 'C'! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/2/2016 10:52'!signalInvalidCustomerRecord 		self error: self class invalidCustomerRecordErrorDescription ! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 18:01'!signalInvalidAddressRecord 		self error: self class invalidAddressRecordErrorDescription ! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 17:54'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 16:01'!signalAddressWithoutCustomerError	self error: self class addressWithoutCustomerErrorDescription.! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:55'!isAddressRecord	^ record first = 'A'! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:57'!importAddress	| newAddress |	self assertThereIsCustsomerForAddress.	self assertValidAddressRecordSize.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newCustomer addAddress: newAddress! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidAddressRecordSize		record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].	! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:56'!assertThereIsCustsomerForAddress	newCustomer isNil ifTrue: [ self signalAddressWithoutCustomerError ].	! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:55'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:54'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/1/2016 17:52'!importRecord		self isCustomerRecord ifTrue: [ ^self importCustomer ].	self isAddressRecord ifTrue: [ ^self importAddress ].		self signalInvalidRecordType! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 10:55'!canImportNextLine	line := readStream nextLine.	^ line notNil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'instance creation' stamp: 'Angel 11/13/2017 22:38'!from: aReadStream on: aSystem	^self new initializeOn: aReadStream on: aSystem ! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/2/2016 10:51'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 16:02'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 18:00'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 17:54'!invalidRecordTypeErrorDescription		^'Invalid record type'! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Environment methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 19:48'!createCustomerSystem	self subclassResponsibility ! !!Environment methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 20:27'!createSupplierSystem	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'testing' stamp: 'ANgel 11/16/2017 19:49'!isCurrent	self subclassResponsibility ! !!Environment class methodsFor: 'accessing' stamp: 'ANgel 11/16/2017 19:44'!current	^self allSubclasses 	detect: [ :anEnvironmentClass | anEnvironmentClass  isCurrent ]	ifFound: [ :anEnvironmentClass | anEnvironmentClass new ] 	ifNone: [ self error: 'No environment found' ].! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!DevelopmentEnvironment methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 19:53'!createCustomerSystem	^TransientCustomerSystem new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:54'!isCurrent	^false! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!IntegrationEnvironment methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 19:52'!createCustomerSystem	^PersistanceCustomerSystem new.! !!IntegrationEnvironment methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 20:31'!createSupplierSystem	^PersistanceSupplierSystem new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'angelmore 11/19/2017 15:54'!isCurrent	^true! !Object subclass: #PersistanceCustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistanceCustomerSystem methodsFor: 'accessing' stamp: 'Angel 11/13/2017 22:55'!persistCustomer: newCustomer	^ session persist: newCustomer! !!PersistanceCustomerSystem methodsFor: 'customers' stamp: 'Angel 11/13/2017 23:02'!allCustomers	^session selectAllOfType: Customer.! !!PersistanceCustomerSystem methodsFor: 'importing' stamp: 'Angel 11/13/2017 22:56'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| customers |	customers := session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer.	"self assert: customers size equals: 1."	^ customers anyOne! !!PersistanceCustomerSystem methodsFor: 'importing' stamp: 'angelmore 11/19/2017 15:40'!importCustomersFrom: inputStream	(CustomerImporter from: inputStream on: self) import! !!PersistanceCustomerSystem methodsFor: 'setup-teardown' stamp: 'Angel 11/13/2017 22:40'!stop	session commit.	session close! !!PersistanceCustomerSystem methodsFor: 'setup-teardown' stamp: 'Angel 11/13/2017 21:06'!start	session :=			(DataBaseSession				for: (Array with: self addressMapping with: self customerMapping)).	session open.	session beginTransaction! !!PersistanceCustomerSystem methodsFor: 'setup-teardown' stamp: 'Angel 11/13/2017 20:41'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistanceCustomerSystem methodsFor: 'setup-teardown' stamp: 'Angel 11/13/2017 20:40'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !Object subclass: #PersistanceSupplierSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistanceSupplierSystem methodsFor: 'importing' stamp: 'ANgel 11/16/2017 20:29'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| customers |	customers := session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer.	"self assert: customers size equals: 1."	^ customers anyOne! !!PersistanceSupplierSystem methodsFor: 'importing' stamp: 'ANgel 11/16/2017 20:53'!importSuppliersFrom: inputStream	(SupplierImporter from: inputStream on: self) import! !!PersistanceSupplierSystem methodsFor: 'importing' stamp: 'angelmore 11/19/2017 16:54'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| supplier|	supplier := session		select: [ :aSupplier| 			aSupplier identificationType = anIdentifycationType				and: [ aSupplier identificationNumber = anIdentificationNumber] ]		ofType: Supplier.	"self assert: customers size equals: 1."	^ supplier anyOne! !!PersistanceSupplierSystem methodsFor: 'accessing' stamp: 'ANgel 11/16/2017 20:50'!persistSupplier: newSupplier	^ session persist: newSupplier! !!PersistanceSupplierSystem methodsFor: 'setup-teardown' stamp: 'ANgel 11/16/2017 20:29'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistanceSupplierSystem methodsFor: 'setup-teardown' stamp: 'angelmore 11/19/2017 16:40'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistanceSupplierSystem methodsFor: 'setup-teardown' stamp: 'ANgel 11/16/2017 21:26'!start	session :=			(DataBaseSession				for: (Array with: self addressMapping with: self customerMapping with: self supplierMapping)).	session open.	session beginTransaction! !!PersistanceSupplierSystem methodsFor: 'setup-teardown' stamp: 'ANgel 11/16/2017 20:29'!stop	session commit.	session close! !!PersistanceSupplierSystem methodsFor: 'setup-teardown' stamp: 'ANgel 11/16/2017 20:29'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistanceSupplierSystem methodsFor: 'customers' stamp: 'ANgel 11/16/2017 21:35'!allSuppliers	^session selectAllOfType: Supplier .! !!PersistanceSupplierSystem methodsFor: 'customers' stamp: 'ANgel 11/16/2017 20:29'!allCustomers	^session selectAllOfType: Customer.! !Object subclass: #Supplier	instanceVariableNames: 'id firstName identificationType identificationNumber addresses customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Supplier methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 20:36'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Supplier methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 20:36'!addressesIsEmpty		^addresses isEmpty! !!Supplier methodsFor: 'as yet unclassified' stamp: 'angelmore 11/19/2017 19:43'!customerCalled: aFirstName ifNone: noneClosure 		^customers detect: [ :anCustomer | anCustomer isAt: aFirstName ] ifNone: noneClosure. ! !!Supplier methodsFor: 'adding' stamp: 'ANgel 11/16/2017 20:38'!addCustomer: aCustomer 	customers add: aCustomer ! !!Supplier methodsFor: 'initialization' stamp: 'ANgel 11/16/2017 20:40'!initialize	super initialize.	addresses := OrderedCollection new.	customers := OrderedCollection new.! !!Supplier methodsFor: 'name' stamp: 'ANgel 11/16/2017 20:36'!firstName		^firstName ! !!Supplier methodsFor: 'name' stamp: 'ANgel 11/16/2017 20:36'!firstName: aName 	firstName := aName! !!Supplier methodsFor: 'identification' stamp: 'ANgel 11/16/2017 20:36'!identificationType		^identificationType ! !!Supplier methodsFor: 'identification' stamp: 'ANgel 11/16/2017 20:36'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Supplier methodsFor: 'identification' stamp: 'angelmore 11/19/2017 16:39'!identificationNumber		^identificationNumber ! !!Supplier methodsFor: 'identification' stamp: 'ANgel 11/16/2017 20:36'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Supplier methodsFor: 'addresses' stamp: 'angelmore 11/19/2017 19:21'!numberOfCustomers		^customers  size! !!Supplier methodsFor: 'addresses' stamp: 'ANgel 11/16/2017 20:36'!addAddress: anAddress 	addresses add: anAddress ! !!Supplier methodsFor: 'addresses' stamp: 'ANgel 11/16/2017 20:36'!addresses	^ addresses! !!Supplier methodsFor: 'addresses' stamp: 'ANgel 11/16/2017 20:36'!numberOfAddresses		^addresses size! !!Supplier methodsFor: 'accessing' stamp: 'ANgel 11/16/2017 20:39'!customers	^ customers! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierImportTest methodsFor: 'tests' stamp: 'angelmore 11/19/2017 19:47'!testImportCustomers	self importSuppliersFrom: self validTestDataWithSuppliers.	self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WasImportedCorrectly.! !!SupplierImportTest methodsFor: 'importing' stamp: 'ANgel 11/16/2017 20:25'!assertImportedSuppliersSizeIsCorrect	self assert: self allSuppliers size equals: 1! !!SupplierImportTest methodsFor: 'importing' stamp: 'ANgel 11/16/2017 20:17'!importSuppliersFrom: inputStream	system importSuppliersFrom: inputStream! !!SupplierImportTest methodsFor: 'importing' stamp: 'angelmore 11/19/2017 16:25'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ system		supplierIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!SupplierImportTest methodsFor: 'asserting' stamp: 'angelmore 11/19/2017 19:32'!assert: supplier hasCustomerWithFirstName: fisrtName lastName: lastName in: town zipCode: zipCode province: province	| customer streetName streetNumber |		customer := supplier addressAt: streetName ifNone: [ self fail ].	self assert: customer streetName equals: streetName.	self assert: customer streetNumber equals: streetNumber.	self assert: customer town equals: town.	self assert: customer zipCode equals: zipCode.	self assert: customer province equals: province.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'angelmore 11/19/2017 19:44'!assert: supplier hasCustomerWithFirstName: firstName lastName: lastName identificationType: identificationType identificationNumber: identificationNumber	| customer |		customer := supplier customerCalled: firstName ifNone:[ self fail ].	self assert: customer firstName equals: firstName .	self assert: customer lastName  equals: lastName .	self assert: customer identificationType  equals: identificationType .	self assert: customer identificationNumber equals: identificationNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'angelmore 11/19/2017 19:24'!assertSupplier1WasImportedCorrectly	| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := self supplierIdentifiedAs: idType numbered: idNumber.		self assert: supplier isNamed: 'Supplier1' identfiedAs: idType withNumber: idNumber numberOfCustomers: 1 andNumberOfAddresses: 1.	self assert: supplier hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'angelmore 11/19/2017 19:20'!assert: supplier isNamed: firstName identfiedAs: idType withNumber: idNumber numberOfCustomers: customersSize andNumberOfAddresses: addressesSize	self assert: supplier firstName equals: firstName.	self assert: supplier identificationType equals: idType.	self assert: supplier identificationNumber equals: idNumber.	self assert: supplier numberOfCustomers equals: customersSize .	self assert: supplier numberOfAddresses equals: addressesSize .! !!SupplierImportTest methodsFor: 'asserting' stamp: 'angelmore 11/19/2017 19:29'!assert: supplier hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := supplier addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.! !!SupplierImportTest methodsFor: 'test data' stamp: 'ANgel 11/16/2017 20:22'!setUp	system := Environment current createSupplierSystem.	system start! !!SupplierImportTest methodsFor: 'test data' stamp: 'angelmore 11/19/2017 16:53'!validTestDataWithSuppliers	^ ReadStream on: 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444A,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 21:34'!allSuppliers	^system allSuppliers! !Object subclass: #SupplierImporter	instanceVariableNames: 'line readStream session record newSupplier system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierImporter methodsFor: 'initialization' stamp: 'ANgel 11/16/2017 20:49'!initializeOn: aReadStream on: aSystem	readStream := aReadStream.	system := aSystem.! !!SupplierImporter methodsFor: 'error signal' stamp: 'ANgel 11/16/2017 20:49'!signalInvalidAddressRecord 		self error: self class invalidAddressRecordErrorDescription ! !!SupplierImporter methodsFor: 'error signal' stamp: 'ANgel 11/16/2017 20:49'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!SupplierImporter methodsFor: 'error signal' stamp: 'ANgel 11/16/2017 21:12'!signalInvalidSupplierRecord 		self error: self class invalidSupplierRecordErrorDescription ! !!SupplierImporter methodsFor: 'error signal' stamp: 'ANgel 11/16/2017 20:49'!signalAddressWithoutCustomerError	self error: self class addressWithoutCustomerErrorDescription.! !!SupplierImporter methodsFor: 'error signal' stamp: 'ANgel 11/16/2017 20:49'!signalInvalidCustomerRecord 		self error: self class invalidCustomerRecordErrorDescription ! !!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'ANgel 11/16/2017 21:29'!importSupplier	self assertValidSupplierRecordSize.		newSupplier := Supplier new.	newSupplier firstName: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth.	^ system persistSupplier: newSupplier.! !!SupplierImporter methodsFor: 'importing' stamp: 'ANgel 11/16/2017 20:49'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!SupplierImporter methodsFor: 'importing' stamp: 'ANgel 11/16/2017 20:52'!importSuppliersFrom: inputStream	system importSuppliersFrom: inputStream! !!SupplierImporter methodsFor: 'testing' stamp: 'ANgel 11/16/2017 21:03'!isSupplierRecord	^ record first = 'S'! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'ANgel 11/16/2017 21:29'!assertValidCustomerRecordSize		record size ~= 5 ifTrue: [ self signalInvalidCustomerRecord ].	! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'ANgel 11/16/2017 21:28'!assertValidSupplierRecordSize		record size ~= 4 ifTrue: [ self signalInvalidSupplierRecord ].	! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'ANgel 11/16/2017 20:57'!importCustomer	| newCustomer |	self assertValidCustomerRecordSize.	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	^newSupplier addCustomer: newCustomer! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'ANgel 11/16/2017 21:05'!isCustomerRecord	^ record first = 'NC'! !!SupplierImporter methodsFor: 'importing - private' stamp: 'ANgel 11/16/2017 20:49'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!SupplierImporter methodsFor: 'importing - private' stamp: 'ANgel 11/16/2017 21:04'!importRecord		self isSupplierRecord ifTrue: [ ^self importSupplier ].	self isCustomerRecord ifTrue: [ ^self importCustomer ].	self isAddressRecord ifTrue: [ ^self importAddress ].		self signalInvalidRecordType! !!SupplierImporter methodsFor: 'importing - private' stamp: 'ANgel 11/16/2017 20:49'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!SupplierImporter methodsFor: 'importing - private' stamp: 'ANgel 11/16/2017 20:49'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'ANgel 11/16/2017 20:49'!isAddressRecord	^ record first = 'A'! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'ANgel 11/16/2017 20:55'!importAddress	| newAddress |	self assertThereIsCustsomerForAddress.	self assertValidAddressRecordSize.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newSupplier addAddress: newAddress! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'ANgel 11/16/2017 20:49'!assertValidAddressRecordSize		record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].	! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'ANgel 11/16/2017 21:30'!assertThereIsCustsomerForAddress	newSupplier isNil ifTrue: [ self signalAddressWithoutCustomerError ].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'ANgel 11/16/2017 20:49'!from: aReadStream on: aSystem	^self new initializeOn: aReadStream on: aSystem ! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'ANgel 11/16/2017 21:13'!invalidSupplierRecordErrorDescription		^'Invalid customer record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'ANgel 11/16/2017 20:49'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'ANgel 11/16/2017 20:49'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'ANgel 11/16/2017 20:49'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'ANgel 11/16/2017 20:49'!invalidRecordTypeErrorDescription		^'Invalid record type'! !Object subclass: #TransientCustomerSystem	instanceVariableNames: 'customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientCustomerSystem methodsFor: 'customers' stamp: 'ANgel 11/16/2017 19:25'!allCustomers	^customers copy! !!TransientCustomerSystem methodsFor: 'importing' stamp: 'ANgel 11/16/2017 19:26'!persistCustomer: aCustomer 	customers add: aCustomer! !!TransientCustomerSystem methodsFor: 'importing' stamp: 'ANgel 11/16/2017 19:26'!start	customers := OrderedCollection new.! !!TransientCustomerSystem methodsFor: 'importing' stamp: 'ANgel 11/16/2017 19:26'!stop! !!TransientCustomerSystem methodsFor: 'importing' stamp: 'angelmore 11/19/2017 15:43'!importCustomersFrom: inputStream 	(CustomerImporter from: inputStream on: self) import! !!TransientCustomerSystem methodsFor: 'importing' stamp: 'ANgel 11/16/2017 19:25'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^customers detect: [ :aCustomer | "delegar respon al customer"			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'angelmore 11/19/2017 15:53'!assertHasIdInstanceVariable: aClass 		(aClass classThatDefinesInstanceVariable: #id) ifNil: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'angelmore 11/19/2017 15:53'!assertIsValidFor: aClass 	(aClass classThatDefinesInstanceVariable: instanceVariableName) ifNil: [ self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ]  ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 19 November 2017 at 7:47:52.468643 pm'!!String methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 19 November 2017 at 7:47:52.46879 pm'!!Object methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !